1. РОЗПОВІСТИ ПРО ПРИЗНАЧЕННЯ ОСНОВИХ КОМПОНЕНТІВ МІКРОСЕРВІСНОЇ АРХІТЕКТУРИ.
	Основні компоненти мікросервісної архітектури:
	 - мікросервіси;
	 - контейнери;
	 - сервісна сітка;
	 - сервісне розгортання;
	 - API шлюз.
	Мікросервіси: Основним компонентом архітектури мікросервісів є автономні сервіси. Вони можуть бути написані будь-якою мовою та функціонувати окремо один від одного, що робить їх ідеальними для впровадження різними командами програмного забезпечення.
	Контейнери: Контейнери — це пакет програмного забезпечення, що працює незалежно. Контейнери працюють для ізоляції кожної служби в одному середовищі. Контейнери також забезпечують ресурсозберігаючі засоби для пакетування послуг і пропонують розробникам різні альтернативи розгортання.
	Сервісна сітка: Меш-сервіс пропонує рівень інфраструктури, який забезпечує додаткову безпеку та забезпечує більш передбачувану поведінку з точки зору зв’язку. Сітка сервісів також використовує побічний шаблон та проксі-сервери для забезпечення динамічного обміну повідомленнями. Це налаштування дозволяє розробнику відмовитися від використання коду під час створення частин програми.
	Сервісне розгортання: Воно допомагає керувати розгортанням і рівномірно розподіляти навантаження. Цей компонент містить інформацію про споживання послуг, постачальника послуг і реєстр послуг. Сервісна сітка використовує їх для розподілу навантажень і адаптації до змін у розгортанні.
	API шлюз: Він може виконувати адміністративні завдання, забезпечувати невелику вагу мікросервісів і виконувати дії з балансування навантаження, коли це необхідно. Шлюз API також забезпечує швидший зв’язок між клієнтами та мікросервісами.

2. ЗОБРАЗИТИ АРХІТЕКТУРУ ІНТЕРНЕТ МАГАЗИНУ (ЧИ ІНШОГО СЕРВІСУ) В ТЕРМІНАХ МІКРОСЕРВІСІВ, ВРАХОВУЮЧІ ІНФРАСТРУКТУРНІ КОМПОНЕНТИ.


3. РОЗПОВІСТИ ПРО ОСНОВНІ ПАТЕРНИ ПРОЕКТУВАННЯ МІКРОСЕРВІСНИХ АРХІТЕКТУР.
	1) Aggregator Pattern: Агрегатор у світі комп’ютерів відноситься до веб-сайту або програми, яка збирає пов’язані елементи даних і відображає їх.  Таким чином, навіть у шаблонах мікросервісів агрегатор є основною веб-сторінкою, яка викликає різні служби для отримання необхідної інформації або досягнення необхідної функціональності.
	   Отже, якщо у нас є дві служби, кожна з яких має свою власну базу даних, тоді агрегатор, який має унікальний ідентифікатор транзакції, буде збирати дані з кожної окремої мікропослуги, застосовуватиме бізнес-логіку та, нарешті, опублікує її як кінцеву точку REST.
	2) API Gateway Design Pattern: Він вирішує такі задачі, як запит до кількох мікросервісів, уніфікація роботи з даними при різних інтерфейсах, трансформація даних мікросервісів відповідно до вимог користувача, обробка записів кількох протоколів. Цей шаблон проектування мікросервісу також можна розглядати як проксі-сервіс для маршрутизації запиту до відповідного мікросервісу.
	3) Chained or Chain of Responsibility Pattern: Якщо у вас є три служби, вишикувані в ланцюг, тоді запит від клієнта спочатку отримує служба A. Потім ця служба спілкується з наступною службою B і збирає дані. Нарешті, друга служба зв’язується з третьою службою, щоб створити консолідований вихід. Усі ці служби використовують синхронний HTTP-запит або відповідь для обміну повідомленнями.
	   Крім того, доки запит не пройде через усі служби та не буде згенеровано відповідні відповіді, клієнт не отримає жодних результатів. Запит від служби A до служби B може виглядати інакше, ніж служби B до послуги C.
	4) Asynchronous Messaging Design Pattern: У цьому типі шаблону проектування мікросервісів усі служби можуть спілкуватися одна з одною, але вони не повинні спілкуватися одна з одною послідовно. Ці запити будуть у черзі. Окрім цього, запит можна також надіслати до служби A, відповідь якої не обов’язково надсилати до тієї самої служби, через яку надійшов запит.
	5) Database or Shared Data Pattern: Можна використовувати базу даних для кожної служби та спільну базу даних для кожної служби, але кожен мікросервіс повинен мати достатню кількість даних для обробки запиту.
	6) Event Sourcing Design Pattern: Він створює події щодо змін у стані програми. Крім того, ці події зберігаються як послідовність подій, щоб допомогти розробникам відстежити, які зміни було зроблено.
	   Отже, за допомогою цього ви завжди можете налаштувати стан програми, щоб впоратися з минулими змінами. Ви також можете запитувати ці події для будь-яких змін даних і одночасно публікувати ці події зі сховища подій.
	7) Branch Pattern: Це шаблон проектування, у якому можна одночасно обробляти запити та відповіді від двох або більше незалежних мікросервісів. Таким чином, на відміну від ланцюжкового шаблону проектування, запит не передається в послідовності, а запит передається до двох або більше взаємовиключних мікросервісів.
	   Цей шаблон проектування розширює шаблон проектування агрегатора та забезпечує гнучкість створення відповідей з кількох ланцюжків або одного ланцюжка.
	8) Command Query Responsibility Segregator (CQRS) Design Pattern: Згідно з цією схемою додаток буде розділено на дві частини: команду та запит. Командна частина оброблятиме всі запити, пов’язані з CREATE, UPDATE, DELETE, тоді як частина запитів піклуватиметься про матеріалізовані представлення. Матеріалізовані подання оновлюються через послідовність подій, які створюються за допомогою шаблону джерела подій.
	9) Decomposition Design Pattern : використовується для зупинки процесу запиту та відповіді, якщо служба не працює. Так, наприклад, припустимо, що клієнт надсилає запит на отримання даних із кількох служб. Але через деякі проблеми один із сервісів не працює. Тепер виникнуть головні дві проблеми: по-перше, оскільки клієнт не матиме жодних відомостей про те, що певна служба не працює, запит постійно надсилатиметься цій службі.
	   Друга проблема полягає в тому, що мережеві ресурси будуть виснажені через низьку продуктивність і поганий досвід користувача. Отже, щоб уникнути подібних проблем, ви можете використовувати шаблон вимикача. За допомогою цього шаблону клієнт буде викликати віддалену службу через проксі. Цей проксі буде в основному поводитися як бар'єр каналу.
	   Таким чином, коли кількість відмов перетинає порогове число, автоматичний вимикач спрацьовує на певний період часу. Потім всі спроби викликати пультслужба не працюватиме протягом цього періоду очікування. Після закінчення цього періоду часу автоматичний вимикач дозволить пройти обмежену кількість тестів, і якщо ці запити будуть успішними, автоматичний вимикач повернеться до нормальної роботи.
	   Інакше, якщо стався збій, період тайм-ауту починається знову.
	10) Strangler Pattern or Vine Pattern: Коли цей шаблон застосовується до веб-додатків, виклик повертається вперед і назад для кожного виклику URI, а служби розбиваються на різні домени. Ці домени будуть розміщені як окремі служби. Відповідно до даного шаблону, дві окремі програми будуть жити поруч в одному просторі URI, і один домен буде взято до уваги в певний момент часу.

4. ORCHERSTRATION VS CHOREOGRAPHY.


5. ОПИСАТИ РЕАЛІЗАЦІЮ ПАТТЕРНУ CIRCUIT BREAKER.


6. ОПИСАТИ БАЗОВІ КОМАНДИ DOCKER-COMPOSE, АБО ІНШОГО ПАКЕТУ, ЯКИЙ ЗАСТОСОВУВАВСЯ В РОБОТІ.


7. ОПИСАТИ МЕХАНІЗМ ЗНАХОДЖЕННЯ МІКРОСЕРВІСІВ ОДНЕ ОДНИМ, ЯК ВІДБУВАЄТЬСЯ ЇХ ГОРИЗОНТАЛЬНЕ МАСШТАБУВАННЯ.


8. РОЛЬ SERVICE DISCOVERY ТА ПРИНЦИП РОБОТИ БАЛАНСУВАЛЬНИКА НА ОБРАНІЙ ТЕХНОЛОГІЇ ПРИ ГОРИЗОНТАЛЬНОМУ МАСШТАБУВАННІ.
