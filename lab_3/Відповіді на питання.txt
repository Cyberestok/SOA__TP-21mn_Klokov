1. РОЗПОВІСТИ ПРО ПРИЗНАЧЕННЯ ОСНОВИХ КОМПОНЕНТІВ МІКРОСЕРВІСНОЇ АРХІТЕКТУРИ.
	Основні компоненти мікросервісної архітектури:
	 - мікросервіси;
	 - контейнери;
	 - сервісна сітка;
	 - сервісне розгортання;
	 - API шлюз.
	Мікросервіси: Основним компонентом архітектури мікросервісів є автономні сервіси. Вони можуть бути написані будь-якою мовою та функціонувати окремо один від одного, що робить їх ідеальними для впровадження різними командами програмного забезпечення.
	Контейнери: Контейнери — це пакет програмного забезпечення, що працює незалежно. Контейнери працюють для ізоляції кожної служби в одному середовищі. Контейнери також забезпечують ресурсозберігаючі засоби для пакетування послуг і пропонують розробникам різні альтернативи розгортання.
	Сервісна сітка: Меш-сервіс пропонує рівень інфраструктури, який забезпечує додаткову безпеку та забезпечує більш передбачувану поведінку з точки зору зв’язку. Сітка сервісів також використовує побічний шаблон та проксі-сервери для забезпечення динамічного обміну повідомленнями. Це налаштування дозволяє розробнику відмовитися від використання коду під час створення частин програми.
	Сервісне розгортання: Воно допомагає керувати розгортанням і рівномірно розподіляти навантаження. Цей компонент містить інформацію про споживання послуг, постачальника послуг і реєстр послуг. Сервісна сітка використовує їх для розподілу навантажень і адаптації до змін у розгортанні.
	API шлюз: Він може виконувати адміністративні завдання, забезпечувати невелику вагу мікросервісів і виконувати дії з балансування навантаження, коли це необхідно. Шлюз API також забезпечує швидший зв’язок між клієнтами та мікросервісами.

2. ЗОБРАЗИТИ АРХІТЕКТУРУ ІНТЕРНЕТ МАГАЗИНУ (ЧИ ІНШОГО СЕРВІСУ) В ТЕРМІНАХ МІКРОСЕРВІСІВ, ВРАХОВУЮЧІ ІНФРАСТРУКТУРНІ КОМПОНЕНТИ.


3. РОЗПОВІСТИ ПРО ОСНОВНІ ПАТЕРНИ ПРОЕКТУВАННЯ МІКРОСЕРВІСНИХ АРХІТЕКТУР.
	1) Aggregator Pattern: Агрегатор у світі комп’ютерів відноситься до веб-сайту або програми, яка збирає пов’язані елементи даних і відображає їх.  Таким чином, навіть у шаблонах мікросервісів агрегатор є основною веб-сторінкою, яка викликає різні служби для отримання необхідної інформації або досягнення необхідної функціональності.
	   Отже, якщо у нас є дві служби, кожна з яких має свою власну базу даних, тоді агрегатор, який має унікальний ідентифікатор транзакції, буде збирати дані з кожної окремої мікропослуги, застосовуватиме бізнес-логіку та, нарешті, опублікує її як кінцеву точку REST.
	2) API Gateway Design Pattern: Він вирішує такі задачі, як запит до кількох мікросервісів, уніфікація роботи з даними при різних інтерфейсах, трансформація даних мікросервісів відповідно до вимог користувача, обробка записів кількох протоколів. Цей шаблон проектування мікросервісу також можна розглядати як проксі-сервіс для маршрутизації запиту до відповідного мікросервісу.
	3) Chained or Chain of Responsibility Pattern: Якщо у вас є три служби, вишикувані в ланцюг, тоді запит від клієнта спочатку отримує служба A. Потім ця служба спілкується з наступною службою B і збирає дані. Нарешті, друга служба зв’язується з третьою службою, щоб створити консолідований вихід. Усі ці служби використовують синхронний HTTP-запит або відповідь для обміну повідомленнями.
	   Крім того, доки запит не пройде через усі служби та не буде згенеровано відповідні відповіді, клієнт не отримає жодних результатів. Запит від служби A до служби B може виглядати інакше, ніж служби B до послуги C.
	4) Asynchronous Messaging Design Pattern: У цьому типі шаблону проектування мікросервісів усі служби можуть спілкуватися одна з одною, але вони не повинні спілкуватися одна з одною послідовно. Ці запити будуть у черзі. Окрім цього, запит можна також надіслати до служби A, відповідь якої не обов’язково надсилати до тієї самої служби, через яку надійшов запит.
	5) Database or Shared Data Pattern: Можна використовувати базу даних для кожної служби та спільну базу даних для кожної служби, але кожен мікросервіс повинен мати достатню кількість даних для обробки запиту.
	6) Event Sourcing Design Pattern: Він створює події щодо змін у стані програми. Крім того, ці події зберігаються як послідовність подій, щоб допомогти розробникам відстежити, які зміни було зроблено.
	   Отже, за допомогою цього ви завжди можете налаштувати стан програми, щоб впоратися з минулими змінами. Ви також можете запитувати ці події для будь-яких змін даних і одночасно публікувати ці події зі сховища подій.
	7) Branch Pattern: Це шаблон проектування, у якому можна одночасно обробляти запити та відповіді від двох або більше незалежних мікросервісів. Таким чином, на відміну від ланцюжкового шаблону проектування, запит не передається в послідовності, а запит передається до двох або більше взаємовиключних мікросервісів.
	   Цей шаблон проектування розширює шаблон проектування агрегатора та забезпечує гнучкість створення відповідей з кількох ланцюжків або одного ланцюжка.
	8) Command Query Responsibility Segregator (CQRS) Design Pattern: Згідно з цією схемою додаток буде розділено на дві частини: команду та запит. Командна частина оброблятиме всі запити, пов’язані з CREATE, UPDATE, DELETE, тоді як частина запитів піклуватиметься про матеріалізовані представлення. Матеріалізовані подання оновлюються через послідовність подій, які створюються за допомогою шаблону джерела подій.
	9) Decomposition Design Pattern : За допомогою цього шаблону ви можете розкласти програму на основі бізнес-можливостей або на основі субдоменів. Але в тому ж сценарії, якщо ви розробляєте програму шляхом декомпозиції піддоменів, ви можете мати служби для кожного класу. Для декомпозиції ви можете використовувати доменно-керований дизайн, за допомогою якого вся модель домену розбита на субдомени.
	   Тоді кожен із цих піддоменів матиме власну модель і область (обмежений контекст). Тепер, коли розробник проектує мікросервіси, він/вона буде проектувати ці сервіси в межах області або обмеженого контексту.
	10) Strangler Pattern or Vine Pattern: Коли цей шаблон застосовується до веб-додатків, виклик повертається вперед і назад для кожного виклику URI, а служби розбиваються на різні домени. Ці домени будуть розміщені як окремі служби. Відповідно до даного шаблону, дві окремі програми будуть жити поруч в одному просторі URI, і один домен буде взято до уваги в певний момент часу.

4. ORCHERSTRATION VS CHOREOGRAPHY.
	Різниця полягає у тому, що оркестровка передбачає активне керування всіма елементами та взаємодіями, як диригент керує музикантами оркестру, тоді як хореографія передбачає встановлення шаблону чи процедури, яку мікросервіси дотримуються під час відтворення музики, не вимагаючи нагляду та інструкцій.
	Оркестровка сервісу являє собою єдиний централізований виконуваний бізнес-процес (оркестровник), який координує взаємодію між різними сервісами. Оркестровник відповідає за виклик і поєднання послуг.
	Відносини між усіма службами-учасниками описуються єдиною кінцевою точкою (тобто складеною службою). Оркестровка включає керування транзакціями між окремими службами. Оркестровка використовує централізований підхід для композиції сервісу.
	Хореографія сервісу — це глобальний опис сервісів-учасників, який визначається обміном повідомленнями, правилами взаємодії та угодами між двома або більше кінцевими точками. У хореографії використовується децентралізований підхід до складу сервісу.
	Хореографія описує взаємодію між кількома службами, де оркестровка представляє контроль з точки зору однієї сторони. Це означає, що хореографія відрізняється від оркестровки щодо того, де повинна знаходитися логіка, яка контролює взаємодію між залученими службами.
	Минув час для підходу лише на основі API RESTful – для архітектури, яка надає бізнес-послуги швидше та надійніше та легко масштабується, кращим підходом є хореографія взаємодії мікросервісів.
	Оскільки керована подіями архітектура та мікросервіси охоплюють ваш ландшафт розробки програмного забезпечення, хореографічний підхід до зв’язку між службами заощадить час і гроші вашої компанії, покращуючи досвід, який ви пропонуєте своїм клієнтам.

5. ОПИСАТИ РЕАЛІЗАЦІЮ ПАТТЕРНУ CIRCUIT BREAKER.
	Як випливає з назви, схема розробки Circuit Breaker використовується для зупинки процесу запиту та відповіді, якщо служба не працює. Так, наприклад, припустимо, що клієнт надсилає запит на отримання даних із кількох служб. Але через деякі проблеми один із сервісів не працює.
	Тепер виникнуть головні дві проблеми: по-перше, оскільки клієнт не матиме жодних відомостей про те, що певна служба не працює, запит постійно надсилатиметься цій службі. Друга проблема полягає в тому, що мережеві ресурси будуть виснажені через низьку продуктивність і поганий досвід користувача. Отже, щоб уникнути подібних проблем, ви можете використовувати шаблон дизайну вимикача.
	За допомогою цього шаблону клієнт буде викликати віддалену службу через проксі. Цей проксі буде в основному поводитися як бар'єр каналу. Таким чином, коли кількість відмов перетинає порогове число, автоматичний вимикач спрацьовує на певний період часу. Тоді всі спроби викликати віддалену службу будуть невдалимицей період очікування.
	Після закінчення цього періоду часу автоматичний вимикач дозволить пройти обмежену кількість тестів, і якщо ці запити будуть успішними, автоматичний вимикач повернеться до нормальної роботи. Інакше, якщо стався збій, період тайм-ауту починається знову.

6. ОПИСАТИ БАЗОВІ КОМАНДИ DOCKER-COMPOSE, АБО ІНШОГО ПАКЕТУ, ЯКИЙ ЗАСТОСОВУВАВСЯ В РОБОТІ.
	"docker-compose -v" - дізнатися версію докер-композ
	"docker-compose build" - створити докер-контейнер
	"docker-compose run --service-ports web" - запуск у режимі відладки
	"docker-compose up" - запуск докер-контейнера
	"docker-compose up -d" - запуск докер-контейнера у фоні
	"docker-compose images" - переглянути образи
	"docker-compose ps" - переглянути список лише запущених контейнерів
	"docker-compose ps --all" - переглянути список як запущених, так і зупинених контейнерів
	"docker-compose start <service name>" - запуск доступного контейнера
	"docker-compose stop <service>" - зупинка запущених контейнерів
	"docker-compose kill <service name>" - примусова зупинка запущених контейнерів
	"docker-compose rm <service name>" - видалення зупинених контейнерів
	"docker-compose down" - зупинити та видалити всі контейнери у сховищі
	
7. ОПИСАТИ МЕХАНІЗМ ЗНАХОДЖЕННЯ МІКРОСЕРВІСІВ ОДНЕ ОДНИМ, ЯК ВІДБУВАЄТЬСЯ ЇХ ГОРИЗОНТАЛЬНЕ МАСШТАБУВАННЯ.
	Мікросервіси можуть зв'язуватися один з одним синхронно або асинхронно.
	Синхронне спілкування використовує протокол HTTP або gRPC для повернення відповіді синхронізації. Клієнт відправляє запит і чекає відповіді від сервісу. Це означає, що код клієнта блокує їхній потік, доки відповідь не надійде від сервера.
	В асинхронному зв’язку клієнт надсилає запит, але не чекає відповіді від служби. Ключовим моментом тут є те, що клієнт не повинен бути заблокованим в очікуванні відповіді. Найпопулярнішим протоколом для цього асинхронного зв’язку є AMQP.
	Асинхронні системи можуть бути реалізовані в режимі «один до одного» або «один до багатьох». У реалізації «один-до-одного» є один виробник і один отримувач, а в реалізації «один до багатьох» є кілька приймачів.
	Горизонтальне масштабування означає масштабування шляхом додавання більшої кількості машин до вашого пулу ресурсів. 

8. РОЛЬ SERVICE DISCOVERY ТА ПРИНЦИП РОБОТИ БАЛАНСУВАЛЬНИКА НА ОБРАНІЙ ТЕХНОЛОГІЇ ПРИ ГОРИЗОНТАЛЬНОМУ МАСШТАБУВАННІ.
