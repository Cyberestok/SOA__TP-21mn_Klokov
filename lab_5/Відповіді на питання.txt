1. ОСНОВНІ АЛГОРИТМИ КВОТУВАННЯ ЧАСТОТИ ЗАПИТІВ. ЇХ ПЕРЕВАГИ ТА НЕДОЛІКИ.
	Leaky Bucket:
	Це алгоритм, який забезпечує простий, інтуїтивно зрозумілий підхід до обмеження швидкості за допомогою черги, яку можна розглядати як відро, що містить запити. При реєстрації запиту система додає його в кінець черги. Обробка для першого елемента в черзі відбувається з регулярним інтервалом або першим прийшов, першим вийшов (FIFO).
	Якщо черга заповнена, то додаткові запити відкидаються (або просочуються). Перевагою цього алгоритму є те, що він згладжує сплески запитів і обробляє їх із приблизно середньою швидкістю. Його також легко реалізувати на одному сервері або балансиру навантаження, і він ефективно використовує пам’ять для кожного користувача, враховуючи обмежений розмір черги.
	Однак сплеск трафіку може заповнити чергу старими запитами та перешкодити обробці останніх запитів. Він також не гарантує, що запити будуть оброблені протягом фіксованого часу. Крім того, якщо ви балансуєте навантаження серверів для стійкості до відмов або збільшення пропускної здатності, ви повинні використовувати політику для координації та забезпечення обмеження між ними.
	Fixed Window:
	Система використовує розмір вікна n секунд (зазвичай із використанням зручних для людини значень, наприклад 60 або 3600 секунд) для відстеження фіксованої швидкості алгоритму вікна. Кожен вхідний запит збільшує лічильник вікна. Він відхиляє запит, якщо лічильник перевищує порогове значення. Перевага цього алгоритму полягає в тому, що він забезпечує обробку останніх запитів без втрати старими запитами.
	Однак один викид трафіку, який виникає поблизу межі вікна, може призвести до обробки вдвічі більшої кількості запитів, оскільки він дозволить запити як для поточного, так і для наступного вікна протягом короткого часу. Крім того, якщо багато споживачів чекають вікна скидання, вони можуть зупинити ваш API одночасно на початку години.
	Sliding Log:
	Обмеження швидкості журналу передбачає відстеження журналу з міткою часу для кожного запиту споживача. Система зберігає ці журнали в упорядкованому за часом хеш-наборі або таблиці. Він також відкидає журнали з часовими мітками, що перевищують порогове значення. Коли надходить новий запит, ми обчислюємо суму журналів, щоб визначити частоту запитів. Якщо запит перевищить порогове значення, він утримується.
	Перевагою цього алгоритму є те, що він не страждає від граничних умов фіксованих вікон. Дотримання ліміту ставок залишатиметься точним. Оскільки система відстежує ковзаючий журнал для кожного споживача, ви не маєте ефекту тисняви, який кидає виклик фіксованим вікнам. Однак зберігати необмежену кількість журналів для кожного запиту може бути дорого.
	Це також дорого обчислювати, оскільки кожен запит вимагає обчислення підсумку попередніх запитів споживача, потенційно в кластері серверів. Як наслідок, він погано масштабується для обробки великих спалахів трафіку або атак на відмову в обслуговуванні.
	Sliding Window:
	Це гібридний підхід, який поєднує низьку вартість обробки алгоритму Fixed Window та покращені граничні умови Sliding Log. Подібно до алгоритму Fixed Window, ми відстежуємо лічильник для кожного фіксованого вікна. Далі ми враховуємо зважене значення частоти запитів попереднього вікна на основі поточної позначки часу, щоб згладити спалахи трафіку.
	Відносно невелика кількість точок даних, необхідних для відстеження кожного ключа, дозволяє масштабувати та розподіляти між великими кластерами. 

2. ЯКІ ПЕРЕВАГИ ЗАБЕЗПЕЧУЄ КВОТУВАННЯ ЧАСТОТИ ЗАПИТІВ. ДЛЯ ЯКИХ СЕРВІСІВ Є ДОЦІЛЬНИМ?
	Розглянемо квотування на прикладі Google Cloud. Квота обмежує кількість конкретного спільного ресурсу Google Cloud, який може використовувати ваш хмарний проект, зокрема обладнання, програмне забезпечення та мережеві компоненти.
	Квоти є частиною системи, яка виконує такі дії:
	- Відстежує ваше використання продуктів і послуг Google Cloud.
	- Обмежує ваше споживання цих ресурсів з причин, зокрема забезпечення чесності та зменшення різкого використання.
	- Підтримує конфігурації, які автоматично забезпечують виконання встановлених обмежень.
	- Надає засоби для внесення або запиту змін до квоти.
	При перевищенні квоти в більшості випадків система негайно блокує доступ до відповідного ресурсу Google, і завдання, яке ви намагаєтеся виконати, не виконується. У більшості випадків квоти застосовуються до кожного хмарного проекту та розподіляються між усіма програмами та IP-адресами, які використовують цей хмарний проект.
	За замовчуванням квоти та обмеження BigQuery застосовуються для кожного проекту . Квоти та ліміти, які застосовуються на іншій основі, вказуються як такі; наприклад, максимальну кількість стовпців на таблицю або максимальну кількість одночасних запитів API на користувача. Конкретні політики відрізняються залежно від доступності ресурсів, профілю користувача, історії використання служби та інших факторів і можуть бути змінені без попередження.
	Квотування доцільно застосовувати до сервісів з великою кількістю запитів за короткий проміжок часу, а також у якості захисту від DOS та DDOS атак.

3. КВОТУВАННЯ ТА ГОРИЗОНТАЛЬНЕ МАСШТАБУВАННЯ КЛІЄНТА.
	Ефективне обмеження швидкості з постійно зростаючим розподіленим кластером є складною задачею. Проблема для полягає в «раптовій» частині: якби використання поступово збільшувалося протягом кількох хвилин, це не було б проблемою: автомасштабування спрацювало б і додало достатньо можливостей, щоб впоратися з нею. Таке велике використання викликає проблеми, лише якщо його дуже швидкий початок означає, що автомасштабування не може вчасно відреагувати.
	Тому необхідно запровадити глобальне майже миттєве обмеження кількості повідомлень для облікового запису. Також треба задовольнити кілька обмежень:
	 - гарантована доставка повідомлень;
	 - відсутність ліміту сліпого переходу;
	 - масштабованість;
	 - стабільність пропускної здатності;
	 - передбачуваність;
	 - швидкий час реакції.
	Для стабільної поведінки за попиту, який перевищує дозволену швидкість, потрібно постійно пригнічувати частину спроб операцій. Кожен обліковий запис у системі має роль десь у кластері (визначається послідовним хешуванням), відповідальним за збір статистики, агрегацію та дотримання обмежень.
	Наприклад, щонайбільше кожні дві секунди кожен із клієнтів цієї ролі здійснює виклик RPC із зведенням будь-яких змінених статистичних даних (кількість повідомлень різного типу було надіслано чи отримано, кількість поточних з’єднань і каналів тощо) з моменту останнього дзвінка, якщо такий був. Оскільки було засновувано обмеження на цій статистиці, можна додати відповідь на виклик RPC, який містив список операцій, які підлягають частковому придушенню,
	і suppressionFactor (тобто частка операцій, які потрібно відхилити), щоб застосувати до кожного. SuppressionFactor — це число з плаваючою точкою між 0 і 1, яке визначає ймовірність того, що ця операція буде дозволена. Так, наприклад, якби `messages.maxRate` мав suppressionFactor 0,5, то кожна публікація (незалежно) мала б 50% шанс бути дозволеною. Це задовольняє обмеження 1: оскільки повідомлення відхиляються під час публікації,
	ми все ще дотримуємося нашої гарантії доставки кожного повідомлення, яке ми приймаємо. Наявність імовірнісного придушення допомагає з обмеженням 4. Тож, слід почати надсилати адміністратору облікового запису статистичні дані про те, скільки повідомлень було б згенеровано, якби вони вдалися, тими спробами публікації, які фактично були відхилені через порушення миттєвого обмеження швидкості.
	Наприклад, якщо ви опублікуєте в каналі з 1000 передплатниками, у разі успіху буде використано 1001 повідомлення з вашого розподілу пакетів (одне для публікації та одне для кожного підписника). Ми почали надсилати це число (в окремій статистиці, яка не враховується у використанні пакета), навіть якщо спробу публікації було відхилено. Це означає, що обмежувач швидкості тепер може знати загальну суму, яку було б надіслано та отримано, якби не було придушення,
	а це означає, що він може просто виконати простий розрахунок швидкості придушення, який був би потрібний для того, щоб успішна публікація призвела до загальної швидкості повідомлень на межі. Це повністю дозволяє уникнути проблеми коливань. У поєднанні з кількома додатковими налаштуваннями це спрацювало достатньо добре. (Одним із таких налаштувань було використання модифікованого moving average, яке ігнорує будь-який поточний підінтервал,
	якщо поточна точка даних нижча за нескориговане середнє. Це означає, що ми не отримуємо коливань через агрегування moving average дискретних інтервалів, але він все ще може швидко реагувати, якщо в поточному інтервалі є раптові стрибки.)